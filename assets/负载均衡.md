# 负载均衡与redis发布订阅

---

如果很多客户端连接1台服务器，进行业务操作没有什么问题，

但是1台服务器在32位linux操作系统，大致的并发量（socketfd1024，通过limit将进程最多能使用的文件描述符调大）支持2万左右。

即单台服务器最多支持2万左右的用户在线，

### 1.如何扩展并发量？

<mark>横向扩展chatServer的数量</mark>：从而提高并发服务器量，

- 如果想提高服务器的并发能力，让更多的用户同时上线，就需要进行集群（在水平方向上扩展多台主机，每一台主机运行的都是独立的chatServer）或者分布式部署，
- 这时客户端向服务端发起连接并没有指定连接哪一台业务服务器，如果都连接同一台服务器将导致连接量过大，服务器压力过高，需要通过nginx（轻松支持5~6万并发）来作为中转指定连接服务端的某台服务器（负载均衡）
- 如果想要继续提升并发量，可以对负载均衡器本身再次集群，负载均衡之前可以使用LVS（偏底层的负载均衡器扩展到十多万并发），负载均衡包含业务负载均衡、传输层负载（通过TCP\UDP分发）、网络层分发（通过IP分发）、数据链路层负载（通过数据帧来分发）

![image-20230510090338969](https://s2.loli.net/2023/05/10/JuH1pkNIFW4gtmY.png)

将3台chatServer服务器，配合一台nginx负载均衡服务器，将并发量扩展至5~6万，

<mark>负载均衡器的作用</mark>：

1. 用户在连接客户端时就不用去连接每一台chatServer了，可以直接连接负载均衡服务器，负载均衡器将client的请求按照负载算法（轮询、按权重、按IP哈希）分发到具体的业务服务器上chatServer，
2. 负载均衡器还需要和ChatServer保持心跳机制，监测chatServer是否故障。（每一次发送一个心跳，就将心跳接收器-1，发送了心跳之后没有得到响应，则将心跳接收器+1，如果心跳接收器+3多次心跳未响应，说明网路不通判断为服务器不能正常提供服务）
3. 能够发现新添加的chatServer设备，方便扩展服务器的数量，在不影响原有正常业务服务器的情况下，动态的添加业务服务器数量，而不用将整个服务端重启。

聊天服务器属于长连接业务，客户端与服务器建立连接后需要一直保持，因为客户端与服务器之间需要一直进行通信与信息传递。

<mark>网络服务器编程常用模型</mark>：

1. 方案1：accept + read/write（非并发服务器）
2. 方案2：accept + fork（process pre connection）
3. 方案3：accept + thread（thread pre connection）
4. 方案4：reactors in threads （one loop per thread）：有一个main reactor负载accept连接，然后将连接分发到某个sub reactor（采用round-robin的方式来选择sub reactor），该连接的所有操作都在sub reactor所处的线程中完成，多个连接可能被分派到多个线程中，以充分利用CPU。
5. reactors in process（one loop per process）：nginx服务器的网络模块设计，基于进程设计采用多个Reacors充当IO进程和工作进程，通过accept锁解决多个Reactors的惊群现象。

### 2.集群之后出现的通信问题？

<mark>如何解决跨业务服务器通信的问题</mark> ? 有些公有信息需要在集群的多台服务器之间进行共享，例如当前在线的用户，

- 集群部署的服务器之间进行通信，最好的方式就是<font color='#BAOC2F'>引入中间件消息队列</font>，解耦各个服务器，使整个系统松耦合。
- 提高服务器的响应能力，节省服务器的带宽资源，每添加一天服务器，只需根据消息队列建立连接即可，不需与其他服务器直接建立连接
- 在集群分布式环境中，常使用的中间件消息队列有ActiveMQ、RabbitMQ、Kafka、都是应用场景广泛、且性能好的消息队列，
- 为集群服务器之间、分布式服务之间提供消息通信，
- 本项目使用的中间件消息队列是基于发布订阅模式的redis，

![image-20230510111634920](https://s2.loli.net/2023/05/10/WrEx4SVlM1JPH83.png)

1. 当用户在某台业务服务器登录成功后，集群中的每一台服务器都会会消息队列进行连接，向消息队列中写入数据，以及从消息队列中取出数据。
2. 每一次有用户在chatServer1中登录后，chatServer1都需要订阅一下消息队列，如果用户杂chatServer2中登录，则chatServer2订阅消息队列（对client2的消息感兴趣），
3. 在消息队列中如果有人给client1发送消息，消息队列就向chatServer1上报数据，
4. 当处于不同服务器上的用户与好友之间通信时，用户先发布publish chat json到消息队列中，
5. 由于好友所在的服务器已经订阅的相关消息，消息队列会将chat json notify到好友所在服务器上
6. 从而，服务器所需要的工作就是向消息队列订阅消息subscribe、发布消息publish，消息队列向服务器主动通知notify（观察者模式）

























































