# 保证消息在客户端时序显示

---

项目在实现上确实没有考虑到消息顺序的问题，因为测试中都是属于局域网的聊天网络环境，环境并不是很复杂，所以基本上不会出现消息的乱序到达的问题，如果是在真实环境中，网络环境是非常复杂的，消息的顺序机制肯定是需要实现的，

在对于支持IM即时聊天消息功能的服务器来说，一定是要求服务端与客户端保持一个TCP长连接，并且服务端会有一个长连接模块，专门保存客户端建立长连接所用的连接信息，连接信息包含了连接使用socketfd，以及连接的时长、连接通信的频率、

<mark>解决方案1：为每条消息添加一个时间戳</mark> 

1. 如果客户端直接按照接受消息的先后显示，有可能会出现消息时序错乱的问题，

2. 理想是给消息添加一个时间戳，当所有到达客户端后根据时间进行排序后再进行显示，

3. 存在问题：如果客户端接受到消息按照1s时间周期进行排序，当出现消息不在同一个排序周期内时，依然会出现时序错乱。

    即没有办法在全局按照时间戳，对消息进行整体排序，无法预知消息到来的时间，

<mark>解决方案2：给每个消息都添加一个序列号seq，0 1 2 3 4 ……</mark> 

当客户端向服务器发送消息时，每个消息除了消息本身还需要携带一个seq消息序列号，对端接收到消息时按照seq消息序列号进行消息的显示，如果其他序列号先到达对端，则将消息缓存到本地，seq+1在本地缓冲中查询是否下一个序列号的消息id，

如果是在群聊中需要维护消息的时序，需要针对群中某个人维护一个seq，

而且如果每个消息都有一个seq序列号，不仅仅能够保证消息的时序到达，还能实现更多的功能，如消息撤回（发送撤回消息请求、请求中带有撤回消息的seq序列号）、

<mark>解决方法2补充：当某个消息丢失时，seq如何处理？</mark> 

如果客户端发送的消息在复杂的网络环境中丢失，导致对端永远也拿不到seq+1的下一条消息，则可以：

1.  对端可以主动的向服务端发送请求，要求发送端向服务端重新发送seq+1的消息，
2. 如果消息发送端重复了3次，都没有成功将消息发送到服务端，则判定该消息丢失无法接收
3. 发送端直接显示消息发送失败，接受端直接更新下一个消息序列号seq+1

